

<!DOCTYPE html>
<html class="writer-html5" lang="zh" >
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>进程间通信 &mdash; APUE v1 文档</title>
  

  
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />

  
  
  
  

  
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/doctools.js"></script>
        <script src="_static/language_data.js"></script>
    
    <script type="text/javascript" src="_static/js/theme.js"></script>

    
    <link rel="index" title="索引" href="genindex.html" />
    <link rel="search" title="搜索" href="search.html" />
    <link rel="next" title="网络IPC：套接字" href="APUE-16.html" />
    <link rel="prev" title="高级I/O" href="APUE-14.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="index.html" class="icon icon-home" alt="Documentation Home"> APUE
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Contents</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="APUE-1.html">UNIX基础知识</a></li>
<li class="toctree-l1"><a class="reference internal" href="APUE-2.html">Unix标准及实现</a></li>
<li class="toctree-l1"><a class="reference internal" href="APUE-3.html">文件I/O</a></li>
<li class="toctree-l1"><a class="reference internal" href="APUE-4.html">文件和目录</a></li>
<li class="toctree-l1"><a class="reference internal" href="APUE-5.html">流和FILE对象</a></li>
<li class="toctree-l1"><a class="reference internal" href="APUE-6.html">系统数据文件和信息</a></li>
<li class="toctree-l1"><a class="reference internal" href="APUE-7.html">进程环境</a></li>
<li class="toctree-l1"><a class="reference internal" href="APUE-8.html">进程控制</a></li>
<li class="toctree-l1"><a class="reference internal" href="APUE-9.html">进程关系</a></li>
<li class="toctree-l1"><a class="reference internal" href="APUE-10.html">信号</a></li>
<li class="toctree-l1"><a class="reference internal" href="APUE-11.html">线程</a></li>
<li class="toctree-l1"><a class="reference internal" href="APUE-12.html">线程控制</a></li>
<li class="toctree-l1"><a class="reference internal" href="APUE-13.html">守护进程</a></li>
<li class="toctree-l1"><a class="reference internal" href="APUE-14.html">高级I/O</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">进程间通信</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#id2">管道</a></li>
<li class="toctree-l2"><a class="reference internal" href="#popenpclose">popen和pclose</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id3">协同进程</a></li>
<li class="toctree-l2"><a class="reference internal" href="#fifo">FIFO</a></li>
<li class="toctree-l2"><a class="reference internal" href="#xsi-ipc">XSI IPC</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id4">标识符和键</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#id5">权限结构</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id6">消息队列</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id7">信号量</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id8">共享存储</a></li>
<li class="toctree-l2"><a class="reference internal" href="#posix">POSIX信号量</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="APUE-16.html">网络IPC：套接字</a></li>
<li class="toctree-l1"><a class="reference internal" href="APUE-17.html">高级进程间通信</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">APUE</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html" class="icon icon-home"></a> &raquo;</li>
        
      <li>进程间通信</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="_sources/APUE-15.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="id1">
<h1>进程间通信<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h1>
<p>进程间通信，InterProcess Communication, 简称IPC。</p>
<div class="section" id="id2">
<h2>管道<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h2>
<p>可以通过pipe函数来创建一个管道：</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;unistd.h&gt;</span><span class="cp"></span>

<span class="kt">int</span> <span class="nf">pipe</span><span class="p">(</span><span class="kt">int</span> <span class="n">fd</span><span class="p">[</span><span class="mi">2</span><span class="p">]);</span>
<span class="c1">// 成功返回0，出错返回-1</span>
</pre></div>
</div>
<p>成功返回后，fd[0]为读而打开，fd[1]为写而打开。fd[1]的输出是fd[0]的输入。</p>
<p>fstat函数对管道的每一端都返回一个FIFO类型的文件描述符。可以用S_ISFIFO宏来测试管道。</p>
<p>通常，进程会先调用pipe，接着调用fork，从而创建从父进程与子进程之间的IPC通道。</p>
<ul class="simple">
<li><p>对于父进程到子进程的通道。父进程关闭管道的读端(fd[0])，子进程关闭写端(fd[1])。</p></li>
<li><p>对于从子进程到父进程的管道，父进程关闭写端(fd[1])，子进程关闭读端(fd[0])。</p></li>
</ul>
<p>当读（read）一个写端已被关闭的管道时，在所有数据都被读取后，read返回0，表示文件结束。</p>
<p>当写（write）一个读端已被关闭的管道时，产生信号SIGPIPE。如果忽略该信号或者捕捉该信号并从其处理程序返回，则write返回−1，errno设置为EPIPE。</p>
<p>一个简单的示例：</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&quot;apue.h&quot;</span><span class="cp"></span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">n</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">fd</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
    <span class="kt">pid_t</span> <span class="n">pid</span><span class="p">;</span>
    <span class="kt">char</span> <span class="n">line</span><span class="p">[</span><span class="n">MAXLINE</span><span class="p">];</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">pipe</span><span class="p">(</span><span class="n">fd</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">err_sys</span><span class="p">(</span><span class="s">&quot;pipe error&quot;</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">((</span><span class="n">pid</span> <span class="o">=</span> <span class="n">fork</span><span class="p">())</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">err_sys</span><span class="p">(</span><span class="s">&quot;fork error&quot;</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">pid</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">close</span><span class="p">(</span><span class="n">fd</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
        <span class="n">write</span><span class="p">(</span><span class="n">fd</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="s">&quot;hello world!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="mi">12</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="n">close</span><span class="p">(</span><span class="n">fd</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
        <span class="n">n</span> <span class="o">=</span> <span class="n">read</span><span class="p">(</span><span class="n">fd</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">line</span><span class="p">,</span> <span class="n">MAXLINE</span><span class="p">);</span>
        <span class="n">write</span><span class="p">(</span><span class="n">STDOUT_FILENO</span><span class="p">,</span> <span class="n">line</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>TELL_WAIT系列函数的使用管道的实现：</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&quot;apue.h&quot;</span><span class="cp"></span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">pfd1</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">pfd2</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>

<span class="kt">void</span> <span class="nf">TELL_WAIT</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">pipe</span><span class="p">(</span><span class="n">pfd1</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">pipe</span><span class="p">(</span><span class="n">pfd2</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">err_sys</span><span class="p">(</span><span class="s">&quot;pipe error&quot;</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">TELL_PARENT</span><span class="p">(</span><span class="kt">pid_t</span> <span class="n">pid</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">write</span><span class="p">(</span><span class="n">pfd2</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="s">&quot;c&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">err_sys</span><span class="p">(</span><span class="s">&quot;write error&quot;</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">WAIT_PARENT</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">char</span> <span class="n">c</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">read</span><span class="p">(</span><span class="n">pfd1</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">c</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">err_sys</span><span class="p">(</span><span class="s">&quot;read error&quot;</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">c</span> <span class="o">!=</span> <span class="sc">&#39;p&#39;</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">err_quit</span><span class="p">(</span><span class="s">&quot;WAIT_PARENT: incorrect data&quot;</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">TELL_CHILD</span><span class="p">(</span><span class="kt">pid_t</span> <span class="n">pid</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">write</span><span class="p">(</span><span class="n">pfd1</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="s">&quot;p&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">err_sys</span><span class="p">(</span><span class="s">&quot;write error&quot;</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">WAIT_CHILD</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">char</span> <span class="n">c</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">read</span><span class="p">(</span><span class="n">pfd2</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">c</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">err_sys</span><span class="p">(</span><span class="s">&quot;read error&quot;</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">c</span> <span class="o">!=</span> <span class="sc">&#39;c&#39;</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">err_quit</span><span class="p">(</span><span class="s">&quot;WAIT_CHILD: incorrect data&quot;</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="popenpclose">
<h2>popen和pclose<a class="headerlink" href="#popenpclose" title="永久链接至标题">¶</a></h2>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp"></span>

<span class="kt">FILE</span><span class="o">*</span> <span class="nf">popen</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">cmdstring</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">type</span><span class="p">);</span>
<span class="c1">// 成功返回文件指针，出错返回NULL</span>
<span class="kt">int</span> <span class="nf">pclose</span><span class="p">(</span><span class="kt">FILE</span><span class="o">*</span> <span class="n">fp</span><span class="p">);</span>
<span class="c1">// 成功返返回cmdstring的终止状态，出错返回-1</span>
</pre></div>
</div>
<p>函数popen先执行fork，然后调用exec执行cmdstring，并且返回一个标准I/O文件指针。</p>
<ul class="simple">
<li><p>如果type是“r”，则文件指针连接到cmdstring的标准输出。</p></li>
<li><p>如果type是“w”，则文件指针连接到cmdstring的标准输入，</p></li>
</ul>
<p>pclose函数关闭标准I/O流，等待命令终止，然后返回shell的终止状态。如果shell不能被执行，则pclose返回的终止状态与shell执行exit(127)一样。</p>
<p>示例程序(popen和pclose的实现)：</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&quot;apue.h&quot;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;errno.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;fcntl.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;sys/wait.h&gt;</span><span class="cp"></span>

<span class="k">static</span> <span class="kt">pid_t</span><span class="o">*</span> <span class="n">childpid</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>  <span class="c1">// pointer to array allocated at run-time</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">maxfd</span><span class="p">;</span>

<span class="kt">FILE</span><span class="o">*</span> <span class="nf">popen</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">cmdstring</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">type</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">pfd</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
    <span class="kt">pid_t</span> <span class="n">pid</span><span class="p">;</span>
    <span class="kt">FILE</span><span class="o">*</span> <span class="n">fp</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">((</span><span class="n">type</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="sc">&#39;r&#39;</span> <span class="o">&amp;&amp;</span> <span class="n">type</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="sc">&#39;w&#39;</span><span class="p">)</span> <span class="o">||</span> <span class="n">type</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">errno</span> <span class="o">=</span> <span class="n">EINVAL</span><span class="p">;</span>
        <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">childpid</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">maxfd</span> <span class="o">=</span> <span class="n">open_max</span><span class="p">();</span>
        <span class="k">if</span> <span class="p">((</span><span class="n">childpid</span> <span class="o">=</span> <span class="n">calloc</span><span class="p">(</span><span class="n">maxfd</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">pid_t</span><span class="p">)))</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">pipe</span><span class="p">(</span><span class="n">pfd</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">pfd</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">maxfd</span> <span class="o">||</span> <span class="n">pfd</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">maxfd</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">close</span><span class="p">(</span><span class="n">pfd</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
        <span class="n">close</span><span class="p">(</span><span class="n">pfd</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
        <span class="n">errno</span> <span class="o">=</span> <span class="n">EMFILE</span><span class="p">;</span>
        <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">((</span><span class="n">pid</span> <span class="o">=</span> <span class="n">fork</span><span class="p">())</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">pid</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">type</span> <span class="o">==</span> <span class="sc">&#39;r&#39;</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">close</span><span class="p">(</span><span class="n">pfd</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">pfd</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="n">STDOUT_FILENO</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">dup2</span><span class="p">(</span><span class="n">pfd</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">STDOUT_FILENO</span><span class="p">);</span>
                <span class="n">close</span><span class="p">(</span><span class="n">pfd</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
            <span class="p">}</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="n">close</span><span class="p">(</span><span class="n">pfd</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">pfd</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">STDIN_FILENO</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">dup2</span><span class="p">(</span><span class="n">pfd</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">STDIN_FILENO</span><span class="p">);</span>
                <span class="n">close</span><span class="p">(</span><span class="n">pfd</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="cm">/* close all descriptors in childpid[] */</span>
        <span class="cm">/* to comply with POSIX.1 */</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">maxfd</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">childpid</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">close</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="n">execl</span><span class="p">(</span><span class="s">&quot;/bin/sh&quot;</span><span class="p">,</span> <span class="s">&quot;sh&quot;</span><span class="p">,</span> <span class="s">&quot;-c&quot;</span><span class="p">,</span> <span class="n">cmdstring</span><span class="p">,</span> <span class="p">(</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="mi">0</span><span class="p">);</span>
        <span class="n">_exit</span><span class="p">(</span><span class="mi">127</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="cm">/* parent */</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">type</span> <span class="o">==</span> <span class="sc">&#39;r&#39;</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">close</span><span class="p">(</span><span class="n">pfd</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
        <span class="k">if</span> <span class="p">((</span><span class="n">fp</span> <span class="o">=</span> <span class="n">fdopen</span><span class="p">(</span><span class="n">pfd</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">type</span><span class="p">))</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="n">close</span><span class="p">(</span><span class="n">pfd</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
        <span class="k">if</span> <span class="p">((</span><span class="n">fp</span> <span class="o">=</span> <span class="n">fdopen</span><span class="p">(</span><span class="n">pfd</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">type</span><span class="p">))</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="n">childpid</span><span class="p">[</span><span class="n">fileno</span><span class="p">(</span><span class="n">fp</span><span class="p">)]</span> <span class="o">=</span> <span class="n">pid</span><span class="p">;</span> <span class="c1">// remember child pid for this fd</span>
    <span class="k">return</span> <span class="n">fp</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">pclose</span><span class="p">(</span><span class="kt">FILE</span><span class="o">*</span> <span class="n">fp</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">fd</span><span class="p">,</span> <span class="n">stat</span><span class="p">;</span>
    <span class="kt">pid_t</span> <span class="n">pid</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">childpid</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">errno</span> <span class="o">=</span> <span class="n">EINVAL</span><span class="p">;</span>
        <span class="k">return</span> <span class="mi">-1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">fd</span> <span class="o">=</span> <span class="n">fileno</span><span class="p">(</span><span class="n">fp</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">fd</span> <span class="o">&gt;</span> <span class="n">maxfd</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">errno</span> <span class="o">=</span> <span class="n">EINVAL</span><span class="p">;</span>
        <span class="k">return</span> <span class="mi">-1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">((</span><span class="n">pid</span> <span class="o">=</span> <span class="n">childpid</span><span class="p">[</span><span class="n">fd</span><span class="p">])</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">errno</span> <span class="o">=</span> <span class="n">EINVAL</span><span class="p">;</span>
        <span class="k">return</span> <span class="mi">-1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">childpid</span><span class="p">[</span><span class="n">fd</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">fclose</span><span class="p">(</span><span class="n">fp</span><span class="p">)</span> <span class="o">==</span> <span class="n">EOF</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="mi">-1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">waitpid</span><span class="p">(</span><span class="n">pid</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">stat</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">errno</span> <span class="o">!=</span> <span class="n">EINTR</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="mi">-1</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">stat</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="id3">
<h2>协同进程<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h2>
<p>UNIX系统过滤程序从标准输入读取数据，向标准输出写数据。当一个过滤程序既产生某个过滤程序的输入，又读取该过滤程序的输出时，它就变成了<strong>协同进程</strong>（coprocess）。</p>
</div>
<div class="section" id="fifo">
<h2>FIFO<a class="headerlink" href="#fifo" title="永久链接至标题">¶</a></h2>
<p>FIFO又被称为<strong>命名管道</strong>。</p>
<p>未命名的管道只能在两个相关的进程之间使用，而且这两个相关的进程还要有一个共同的创建了它们的祖先进程。但是，通过FIFO，不相关的进程也能交换数据。</p>
<p>可以使用mkfifo函数来创建一个FIFO：</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;sys/stat.h&gt;</span><span class="cp"></span>

<span class="kt">int</span> <span class="nf">mkfifo</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">path</span><span class="p">,</span> <span class="kt">mode_t</span> <span class="n">mode</span><span class="p">);</span>
<span class="kt">int</span> <span class="nf">mkfifoat</span><span class="p">(</span><span class="kt">int</span> <span class="n">fd</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">path</span><span class="p">,</span> <span class="kt">mode_t</span> <span class="n">mode</span><span class="p">);</span>
<span class="c1">// 成功返回0，出错返回-1</span>
</pre></div>
</div>
<p>mode参数的可选值与open函数中mode参数的相同.</p>
<p>带at类型的函数依旧是原来的模式：</p>
<ul class="simple">
<li><p>如果path参数指定的是绝对路径名，则fd参数会被忽略，mkfifoat函数的行为和mkfifo类似。</p></li>
<li><p>如果path参数指定的是相对路径名，则fd参数是一个打开目录的有效文件描述符，。</p></li>
<li><p>如果path参数指定的是相对路径名，并且fd参数有一个特殊值AT_FDCWD，则路径名以当前目录开始，mkfifoat和mkfifo类似。</p></li>
</ul>
<p>创建FIFO后，要使用open来打开该FIFO。</p>
<p>open FIFO时的非阻塞标志(O_NONBLOCK)的影响：</p>
<ul class="simple">
<li><p>在一般情况下（没有指定O_NONBLOCK），只读open要阻塞到某个其他进程为写而打开这个FIFO为止。只写open要阻塞到某个其他进程为读而打开它为止。</p></li>
<li><p>如果指定了O_NONBLOCK，则只读open立即返回。如果没有进程为读而打开一个FIFO，那么只写open将返回−1，并将errno设置成ENXIO。</p></li>
</ul>
</div>
<div class="section" id="xsi-ipc">
<h2>XSI IPC<a class="headerlink" href="#xsi-ipc" title="永久链接至标题">¶</a></h2>
<p>有三种XSI IPC：消息队列、信号量和共享存储器。</p>
<div class="section" id="id4">
<h3>标识符和键<a class="headerlink" href="#id4" title="永久链接至标题">¶</a></h3>
<p>每个内核中的IPC结构（消息队列、信号量或共享存储段）都用一个非负整数的标识符（identifier）加以引用。</p>
<p>每个IPC对象都与一个键（key，对应的类型为key_t）相关联，将这个键作为该对象的外部名。</p>
<p>使客户进程和服务器进程在同一IPC结构上汇聚的方法：</p>
<ol class="arabic simple">
<li><p>服务器进程可以指定键IPC_PRIVATE创建一个新IPC结构，将返回的标识符存放在某处（如一个文件）以便客户进程取用。键IPC_PRIVATE保证服务器进程创建一个新IPC结构。</p></li>
<li><p>在一个公用头文件中定义一个客户进程和服务器进程都认可的键。然后服务器进程指定此键创建一个新的IPC结构。</p></li>
<li><p>客户进程和服务器进程认同一个路径名和项目ID（项目ID是0～255之间的字符值），接着，调用函数ftok将这两个值变换为一个键。然后在方法（2）中使用此键。</p></li>
</ol>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;sys/ipc.h&gt;</span><span class="cp"></span>

<span class="kt">key_t</span> <span class="nf">ftok</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">path</span><span class="p">,</span> <span class="kt">int</span> <span class="n">fd</span><span class="p">);</span>
<span class="c1">// 成功返回键，出错返回(key_t)-1</span>
</pre></div>
</div>
<p>决不能指定IPC_PRIVATE作为键来引用一个现有队列，这个特殊的键值总是用于创建一个新队列。</p>
<p>如果希望创建一个新的IPC结构，而且要确保没有引用具有同一标识符的一个现有IPC结构，那么必须在flag中同时指定IPC_CREAT和IPC_EXCL位。这样做了以后，如果IPC结构已经存在就会造成出错，返回EEXIST。</p>
</div>
</div>
<div class="section" id="id5">
<h2>权限结构<a class="headerlink" href="#id5" title="永久链接至标题">¶</a></h2>
<p>XSI
IPC为每个IPC结构都关联了ipc_perm结构。该结构规定了权限和所有者，它至少包括下列成员：</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="nc">ipc_perm</span> <span class="p">{</span>
    <span class="kt">uid_t</span> <span class="n">uid</span><span class="p">;</span>      <span class="cm">/* owner&#39;s effective user id */</span>
    <span class="kt">gid_t</span> <span class="n">gid</span><span class="p">;</span>      <span class="cm">/* owner&#39;s effective group id */</span>
    <span class="kt">uid_t</span> <span class="n">cuid</span><span class="p">;</span>     <span class="cm">/* creator&#39;s effective user id */</span>
    <span class="kt">gid_t</span> <span class="n">cgid</span><span class="p">;</span>     <span class="cm">/* creator&#39;s effective group id */</span>
    <span class="kt">mode_t</span> <span class="n">mode</span><span class="p">;</span>    <span class="cm">/* access modes */</span>
    <span class="cm">/* more fi*/</span>
<span class="p">};</span>
</pre></div>
</div>
<p>mode字段是S_IRUSR，S_IWUSR等9个值的组合。</p>
</div>
<div class="section" id="id6">
<h2>消息队列<a class="headerlink" href="#id6" title="永久链接至标题">¶</a></h2>
<p>消息队列是消息的链接表，存储在内核中，由消息队列标识符(队列ID)标识。</p>
<p>msgget用于创建一个新队列或打开一个现有队列。msgsnd将新消息添加到队列尾端。msgrcv用于从队列中取消息。</p>
<p>每个队列都有一个msqid_ds结构与其相关联：</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="nc">msqid_ds</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="nc">ipc_perm</span> <span class="n">msg_perm</span><span class="p">;</span>   <span class="c1">// 权限结构，可参考上一部分</span>
    <span class="n">msgqnum_t</span> <span class="n">msg_qnum</span><span class="p">;</span>         <span class="c1">// num of messages on queue</span>
    <span class="n">msglen_t</span> <span class="n">msg_qbytes</span><span class="p">;</span>        <span class="c1">// max num of bytes on queue</span>
    <span class="kt">pid_t</span> <span class="n">msg_lspid</span><span class="p">;</span>            <span class="c1">// pid of last msgsnd()</span>
    <span class="kt">pid_t</span> <span class="n">msg_lrpid</span><span class="p">;</span>            <span class="c1">// pid of last msgrcv()</span>
    <span class="kt">time_t</span> <span class="n">msg_stime</span><span class="p">;</span>           <span class="c1">// last-msgsnd() time</span>
    <span class="kt">time_t</span> <span class="n">msg_rtime</span><span class="p">;</span>           <span class="c1">// last-msgrcv() time</span>
    <span class="kt">time_t</span> <span class="n">msg_ctime</span><span class="p">;</span>           <span class="c1">// last change time</span>
<span class="p">};</span>
</pre></div>
</div>
<p>msgget的原型如下：</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;sys/msg.h&gt;</span><span class="cp"></span>

<span class="kt">int</span> <span class="nf">msgget</span><span class="p">(</span><span class="kt">key_t</span> <span class="n">key</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flag</span><span class="p">);</span>
<span class="c1">// 成功返回消息队列ID，出错返回-1</span>
</pre></div>
</div>
<p>创建新队列时，会对msqid_ds结构进行初始化：</p>
<ul>
<li><p>初始化ipc-perm结构。其中的mode成员会按flag中的相应权限位设置。flag的值如下：</p>
<div class="figure align-default" id="id9">
<img alt="image-20210512091501715" src="https://gitee.com/snow_zhao/img/raw/master/img/image-20210512091501715.png" />
<p class="caption"><span class="caption-text">image-20210512091501715</span><a class="headerlink" href="#id9" title="永久链接至图片">¶</a></p>
</div>
</li>
<li><p>msg_qnum、msg_lspid、msg_lrpid、msg_stime和msg_rtime都设置为0。</p></li>
<li><p>msg_ctime设置为当前时间。</p></li>
<li><p>msg_qbytes设置为系统限制值。</p></li>
</ul>
<p>返回的队列ID可以用于其他几个函数。</p>
<p>msgctl是队列相关的垃圾桶函数(即能干很多事情)：</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;sys/msg.h&gt;</span><span class="cp"></span>

<span class="kt">int</span> <span class="nf">msgctl</span><span class="p">(</span><span class="kt">int</span> <span class="n">msqid</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cmd</span><span class="p">,</span> <span class="k">struct</span> <span class="nc">msqid_ds</span><span class="o">*</span> <span class="n">buf</span><span class="p">);</span>
<span class="c1">// 成功返回0，出错返回-1</span>
</pre></div>
</div>
<p>msqid即为队列ID。</p>
<p>cmd的取值有以下几种情况：</p>
<ul class="simple">
<li><p>IPC_STAT：将此队列的msqid_ds结构存放在buf指向的结构中。</p></li>
<li><p>IPC_SET：将字段 msg_perm.uid、msg_perm.gid、msg_perm.mode 和
msg_qbytes从buf指向的结构复制到与这个队列相关的msqid_ds结构中。</p></li>
<li><p>IPC_RMID：从系统中删除该消息队列以及仍在该队列中的所有数据。这种删除立即生效。仍在使用这一消息队列的其他进程在它们下一次试图对此队列进行操作时，将得到EIDRM错误。</p></li>
</ul>
<blockquote>
<div><p>后面两条命令有权限要求：要么进程的有效用户ID等于msg_perm.cuid或msg_perm.uid，要么具有超级用户特权。并且只有超级用户才能增加msg_qbytes的值。</p>
</div></blockquote>
<p>msgsnd用于将数据放到消息队列中：</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;sys/msg.h&gt;</span><span class="cp"></span>

<span class="kt">int</span> <span class="nf">msgsnd</span><span class="p">(</span><span class="kt">int</span> <span class="n">msqid</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span><span class="o">*</span> <span class="n">ptr</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">nbytes</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flag</span><span class="p">);</span>
<span class="c1">// 成功返回0，出错返回-1</span>
</pre></div>
</div>
<p>msqid为队列ID。</p>
<p>ptr指向一个长整型数，长整型数后面的是消息数据。长整型数表示消息类型(为正)，后面消息数据的长度由nbytes表明。如发送的最长消息为512字节，则可定义以下结构：</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="nc">mymesg</span> <span class="p">{</span>
    <span class="kt">long</span> <span class="n">mtype</span><span class="p">;</span>
    <span class="kt">char</span> <span class="n">mtext</span><span class="p">[</span><span class="mi">512</span><span class="p">];</span>
<span class="p">};</span>
</pre></div>
</div>
<p>ptr就是一个指向mymesg结构的指针。</p>
<p>接收者可以使用消息类型(mtype字段)以非先进先出的次序取消息。</p>
<p>参数flag的值可以指定为IPC_NOWAIT。若消息队列已满（或者是队列中的消息总数等于系统限制值，或队列中的字节总数等于系统限制值），msgsnd立即出错返回EAGAIN。</p>
<p>如果没有指定IPC_NOWAIT，则进程会一直阻塞到：有空间可以容纳要发送的消息；或者从系统中删除了此队列(返回EIDRM错误)；或者捕捉到一个信号，并从信号处理程序返回(返回EINTR错误)。</p>
<p>对删除消息队列的处理不是很完善。每个消息队列没有维护引用计数器（打开文件有这种计数器），所以在队列被删除以后，仍在使用这一队列的进程在下次对队列进行操作时会出错返回。</p>
<p>msgsnd返回成功时，消息队列相关的msqid_ds结构会随之更新，表明调用的进程ID（msg_lspid）、调用的时间（msg_stime）以及队列中新增的消息（msg_qnum）。</p>
<p>msgrcv用于从队列中取消息：</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;sys/msg.h&gt;</span><span class="cp"></span>

<span class="kt">ssize_t</span> <span class="nf">msgrcv</span><span class="p">(</span><span class="kt">int</span> <span class="n">msqid</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span><span class="o">*</span> <span class="n">ptr</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">nbytes</span><span class="p">,</span> <span class="kt">long</span> <span class="n">type</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flag</span><span class="p">);</span>
<span class="c1">// 成功返回消息数据的长度，出错返回-1</span>
</pre></div>
</div>
<p>ptr参数指向一个长整型数（其中存储的是返回的消息类型），其后跟随的是存储实际消息数据的缓冲区。nbytes指定数据缓冲区的长度。</p>
<p>若返回的消息长度大于nbytes，而且在flag中设置了MSG_NOERROR位，则该消息会被截断。如果没有设置这一标志，而消息又太长，则出错返回E2BIG（消息仍留在队列中）。</p>
<p>参数type可以指定想要哪一种消息：</p>
<ul class="simple">
<li><p>type == 0：返回队列中的第一个消息。</p></li>
<li><p>type &gt; 0：返回队列中消息类型为type的第一个消息。</p></li>
<li><p>type &lt;
0：返回队列中消息类型值小于等于type绝对值的消息，如果这种消息有若干个，则取类型值最小的消息。</p></li>
</ul>
<p>flag值可以指定为IPC_NOWAIT，使操作不阻塞。如果没有所指定类型的消息可用，则msgrcv返回−1，error设置为ENOMSG。</p>
<p>如果没有指定IPC_NOWAIT，则进程会一直阻塞到有了指定类型的消息可用，或者从系统中删除了此队列（返回−1，error设置为EIDRM），或者捕捉到一个信号并从信号处理程序返回（这会导致msgrcv返回−1，errno设置为EINTR）。</p>
<p>msgrcv成功执行时，内核会更新与该消息队列相关联的msgid_ds结构，以指示调用者的进程ID（msg_lrpid）和调用时间（msg_rtime），并指示队列中的消息数减少了1个（msg_qnum）。</p>
</div>
<div class="section" id="id7">
<h2>信号量<a class="headerlink" href="#id7" title="永久链接至标题">¶</a></h2>
<p>XSI信号量并非是单个非负值，而是含有一个或多个信号量的集合。创建信号量时，要制定集合中信号量的个数。</p>
<p>内核为每个信号量集合维护一个semid_ds结构：</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="nc">semid_ds</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="nc">ipc_perm</span> <span class="n">sem_perm</span><span class="p">;</span>   <span class="c1">// 权限结构</span>
    <span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">sem_nsems</span><span class="p">;</span>   <span class="c1">// num of semaphores in set</span>
    <span class="kt">time_t</span> <span class="n">sem_otime</span><span class="p">;</span>           <span class="c1">// last-semop() time</span>
    <span class="kt">time_t</span> <span class="n">sem_ctime</span><span class="p">;</span>           <span class="c1">// last-change time</span>
<span class="p">};</span>
</pre></div>
</div>
<p>每个信号量由一个无名结构表示，至少包含以下成员：</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="p">{</span>
    <span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">semval</span><span class="p">;</span>  <span class="c1">// semaphore value, always &gt;= 0</span>
    <span class="kt">pid_t</span> <span class="n">sempid</span><span class="p">;</span>           <span class="c1">// pid for last operation</span>
    <span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">semncnt</span><span class="p">;</span> <span class="c1">// num of processes awaiting semval &gt; curval</span>
    <span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">semzcnt</span><span class="p">;</span> <span class="c1">// num of processes awaiting semval == 0</span>
<span class="p">};</span>
</pre></div>
</div>
<p>可以通过semget函数来获得一个信号量ID：</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;sys/sem.h&gt;</span><span class="cp"></span>

<span class="kt">int</span> <span class="nf">semget</span><span class="p">(</span><span class="kt">key_t</span> <span class="n">key</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nsems</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flag</span><span class="p">);</span>
<span class="c1">// 成功返回信号量ID，出错返回-1</span>
</pre></div>
</div>
<p>创建一个新集合时，内核会这样初始化semid_ds结构：</p>
<ul class="simple">
<li><p>icp_perm结构的初始化与消息队列类似。</p></li>
<li><p>sem_otime设置为0。</p></li>
<li><p>sem_ctime设置为当前时间。</p></li>
<li><p>sem_nsems设置为nsems参数。</p></li>
</ul>
<p>信号量同样有一个垃圾桶函数semctl：</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;sys/sem.h&gt;</span><span class="cp"></span>

<span class="kt">int</span> <span class="nf">semctl</span><span class="p">(</span><span class="kt">int</span> <span class="n">semid</span><span class="p">,</span> <span class="kt">int</span> <span class="n">semnum</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cmd</span><span class="p">,</span> <span class="p">...</span><span class="cm">/* union semun arg */</span><span class="p">);</span>
<span class="c1">// 返回值见下方</span>
</pre></div>
</div>
<p>union semun的结构如下：</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">union</span> <span class="nc">semun</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">val</span><span class="p">;</span>                <span class="c1">// for SETVAL</span>
    <span class="k">struct</span> <span class="nc">semid_ids</span><span class="o">*</span> <span class="n">buf</span><span class="p">;</span>  <span class="c1">// for IPC_STAT and ICP_SET</span>
    <span class="kt">unsigned</span> <span class="kt">short</span><span class="o">*</span> <span class="n">array</span><span class="p">;</span>  <span class="c1">// for GETALL and SETALL</span>
<span class="p">};</span>
</pre></div>
</div>
<p>cmd参数的可能取值：</p>
<ul class="simple">
<li><p>IPC_STAT：对此集合取semid_ds结构，并存储在由arg.buf指向的结构中。</p></li>
<li><p>IPC_SET：按arg.buf指向的结构中的值，设置与此集合相关的结构中的sem_perm.uid、sem_perm.gid和sem_perm.mode字段。</p></li>
<li><p>IPC_RMID：从系统中删除该信号量集合。这种删除是立即发生的。删除时仍在使用此信号量集合的其他进程，在它们下次试图对此信号量集合进行操作时，将出错返回EIDRM。</p></li>
<li><p>GETVAL：返回成员semnum的semval值。</p></li>
<li><p>SETVAL：设置成员semnum的semval值。该值由arg.val指定。</p></li>
<li><p>GETPID：返回成员semnum的sempid值。</p></li>
<li><p>GETNCNT：返回成员semnum的semncnt值。</p></li>
<li><p>GETZCNT：返回成员semnum的semzcnt值。</p></li>
<li><p>GETALL：取该集合中所有的信号量值。这些值存储在arg.array指向的数组中。</p></li>
<li><p>SETALL：将该集合中所有的信号量值设置成arg.array指向的数组中的值。</p></li>
</ul>
<blockquote>
<div><p>ICP_SET和ICP_RMID的权限要求和消息队列中的心痛</p>
</div></blockquote>
<p>对于除GETALL以外的所有GET命令，semctl函数都返回相应值。对于其他命令，若成功则返回值为0，若出错，则设置errno并返回−1。</p>
<p>函数semop自动执行信号量集合上的操作数组：</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;sys/sem.h&gt;</span><span class="cp"></span>

<span class="kt">int</span> <span class="nf">semop</span><span class="p">(</span><span class="kt">int</span> <span class="n">semid</span><span class="p">,</span> <span class="k">struct</span> <span class="nc">sembuf</span> <span class="n">semoparray</span><span class="p">[],</span> <span class="kt">size_t</span> <span class="n">nops</span><span class="p">);</span>
<span class="c1">// 返回值：若成功，返回0；若出错，返回−1</span>
</pre></div>
</div>
<p>其中sembuf结构如下：</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="nc">sembuf</span> <span class="p">{</span>
    <span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">sem_num</span><span class="p">;</span> <span class="c1">// 信号量的在信号量集合中序号，[0, nsems-1]</span>
    <span class="kt">short</span> <span class="n">sem_op</span><span class="p">;</span>           <span class="c1">// operation(neg, 0, or pos)</span>
    <span class="kt">short</span> <span class="n">sem_flg</span><span class="p">;</span>          <span class="c1">// ICP_NOWAIT, SEM_UNDO</span>
<span class="p">};</span>
</pre></div>
</div>
<ol class="arabic simple">
<li><p>若sem_op为正值。信号量的值加sem_op。如果指定了undo标志，则变为减去sem_op。</p></li>
<li><p>若sem_op为负值。若信号量值&gt;=sem_op的绝对值，则信号量的值加sem_op(加一个负值就相当于减小)。如果指定了undo标志，则变为减去sem_op。若信号量值&lt;sem_op的绝对值，则：</p>
<ul class="simple">
<li><p>若指定了IPC_NOWAIT，则semop出错返回EAGAIN。</p></li>
<li><p>若未指定IPC_NOWAIT，则信号量的semncnt值加1，然后调用进程被挂起直至下列事件之一发生：</p>
<ul>
<li><p>此信号量值变成大于等于sem_op的绝对值。然后信号量的semncnt值减1，并且从信号量值中减去sem_op的绝对值。如果指定了undo标志，变为加。</p></li>
<li><p>从系统中删除了此信号量。在这种情况下，函数出错返回EIDRM。</p></li>
<li><p>进程捕捉到一个信号，并从信号处理程序返回，在这种情况下，此信号量的semncnt值减1，并且函数出错返回EINTR。</p></li>
</ul>
</li>
</ul>
</li>
<li><p>若sem_op为0，这表示调用进程希望等待到该信号量值变成0。</p>
<ul class="simple">
<li><p>如果信号量值当前是0，则此函数立即返回。</p></li>
<li><p>如果信号量值非0，则：</p>
<ul>
<li><p>若指定了IPC_NOWAIT，则出错返回EAGAIN。</p></li>
<li><p>若未指定IPC_NOWAIT，则该信号量的semzcnt加1，然后调用进程被挂起，直至下列的一个事件发生：</p>
<ul>
<li><p>此信号量值变成0。此信号量的semzcnt值减1。</p></li>
<li><p>从系统中删除了此信号量。在这种情况下，函数出错返回EIDRM。</p></li>
<li><p>进程捕捉到一个信号，并从信号处理程序返回。在这种情况下，此信号量的semzcnt值减1，并且函数出错返回EINTR。</p></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<p>semop函数具有原子性，它或者执行数组中的所有操作，或者一个也不做。</p>
</div>
<div class="section" id="id8">
<h2>共享存储<a class="headerlink" href="#id8" title="永久链接至标题">¶</a></h2>
<p>XSI共享存储和内存映射的文件的不同之处在于，共享存储没有相关的文件。XSI共享存储段是内存的匿名段。</p>
<p>内核为每个共享内存段维护着一个shmid_ds结构：</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="nc">shmid_ids</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="nc">ipc_perm</span> <span class="n">shm_perm</span><span class="p">;</span>   <span class="cm">/* 权限结构 */</span>
    <span class="kt">size_t</span> <span class="n">shm_segsz</span><span class="p">;</span>           <span class="cm">/* size of segment in bytes */</span>
    <span class="kt">pid_t</span> <span class="n">shm_lpid</span><span class="p">;</span>             <span class="cm">/* pid of last shmop() */</span>
    <span class="kt">pid_t</span>  <span class="n">shm_cpid</span><span class="p">;</span>            <span class="cm">/* pid of creator */</span>
    <span class="n">shmatt_t</span> <span class="n">shm_nattch</span><span class="p">;</span>        <span class="cm">/* number of current attaches */</span>
    <span class="kt">time_t</span> <span class="n">shm_atime</span><span class="p">;</span>           <span class="cm">/* last-attach time */</span>
    <span class="kt">time_t</span> <span class="n">shm_dtime</span><span class="p">;</span>           <span class="cm">/* last-detach time */</span>
    <span class="kt">time_t</span> <span class="n">shm_ctime</span><span class="p">;</span>           <span class="cm">/* last-change time */</span>
<span class="p">};</span>
</pre></div>
</div>
<p>可以通过shmget函数来获取一个共享存储标识符。</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;sys/shm.h&gt;</span><span class="cp"></span>

<span class="kt">int</span> <span class="nf">shmget</span><span class="p">(</span><span class="kt">key_t</span> <span class="n">key</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flag</span><span class="p">);</span>
<span class="c1">// 成功返回共享存储ID，出错返回-1</span>
</pre></div>
</div>
<p>创建一个新共享存储段时，内核会这样初始化shmid_ds结构：</p>
<ul class="simple">
<li><p>icp_perm结构的初始化与消息队列类似。</p></li>
<li><p>shm_lpid、shm_nattach、shm_atime和shm_dtime都设置为0。</p></li>
<li><p>sem_ctime设置为当前时间。</p></li>
<li><p>shm_segsz设置为size参数。</p></li>
</ul>
<p>参数size是该共享存储段的长度，以字节为单位。实现通常将其向上取为系统页长的整倍数。但是，若应用指定的size值并非系统页长的整倍数，那么最后一页的余下部分是不可使用的。</p>
<p>如果正在创建一个新段（通常在服务器进程中），则必须指定其size。如果正在引用一个现存的段（一个客户进程），则将size指定为0。当创建一个新段时，段内的内容初始化为0。</p>
<p>共享存储同样有一个垃圾桶函数shmctl：</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;sys/shm.h&gt;</span><span class="cp"></span>

<span class="kt">int</span> <span class="nf">shmctl</span><span class="p">(</span><span class="kt">int</span> <span class="n">shmid</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cmd</span><span class="p">,</span> <span class="k">struct</span> <span class="nc">shmid_ds</span><span class="o">*</span> <span class="n">buf</span><span class="p">);</span>
<span class="c1">// 成功返回0，出错返回-1</span>
</pre></div>
</div>
<p>cmd参数的可能值：</p>
<ul class="simple">
<li><p>IPC_STAT：取此段的shmid_ds结构，并将它存储在由buf指向的结构中。</p></li>
<li><p>IPC_SET：按buf指向的结构中的值设置与此共享存储段相关的shmid_ds
结构中的下列3个字段：shm_perm.uid、shm_perm.gid和shm_perm.mode。</p></li>
<li><p>IPC_RMID：从系统中删除该共享存储段。因为每个共享存储段维护着一个连接计数（shmid_ds结构中的shm_nattch字段），所以除非使用该段的最后一个进程终止或与该段分离，否则不会实际上删除该存储段。不管此段是否仍在使用，该段标识符都会被立即删除，所以不能再用shmat与该段连接。</p></li>
<li><p>SHM_LOCK：在内存中对共享存储段加锁。此命令只能由超级用户执行。</p></li>
<li><p>SHM_UNLOCK：解锁共享存储段。此命令只能由超级用户执行。</p></li>
</ul>
<blockquote>
<div><p>IPC_SET和ICP_RMID的权限要求与之前相同。</p>
<p>最后两个命令并非SUS的组成部分。Linux和Solaris提供了这两个命令。</p>
</div></blockquote>
<p>一旦创建了一个共享存储段，进程就可调用shmat将其连接到它的地址空间中。</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;sys/shm.h&gt;</span><span class="cp"></span>

<span class="kt">void</span><span class="o">*</span> <span class="nf">shmat</span><span class="p">(</span><span class="kt">int</span> <span class="n">shmid</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span><span class="o">*</span> <span class="n">addr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flag</span><span class="p">);</span>
<span class="c1">// 成功返回指向共享存储段的指针，出错返回-1</span>
</pre></div>
</div>
<p>共享存储段连接到调用进程的哪个地址上与addr参数以及flag中是否指定SHM_RND位有关：</p>
<ul class="simple">
<li><p>如果addr为0，则此段连接到由内核选择的第一个可用地址上。这是推荐的使用方式。</p></li>
<li><p>如果addr非0，并且没有指定SHM_RND，则此段连接到addr所指定的地址上。</p></li>
<li><p>如果addr非0，并且指定了SHM_RND，则此段连接到（addr−(addr mod
SHMLBA)）所表示的地址上。SHM_RND命令的意思是“取整”。SHMLBA的意思是“低边界地址倍数”，它总是2的乘方。该算式是将地址向下取最近1个SHMLBA的倍数。</p></li>
</ul>
<p>如果在flag中指定了SHM_RDONLY位，则以只读方式连接此段，否则以读写方式连接此段。</p>
<p>当对共享存储段的操作已经结束时，则调用shmdt与该段分离。注意，这并不从系统中删除其标识符以及其相关的数据结构。该标识符仍然存在，直至某个进程（一般是服务器进程）带IPC_RMID命令的调用shmctl特地删除它为止。</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;sys/shm.h&gt;</span><span class="cp"></span>

<span class="kt">int</span> <span class="nf">shmdt</span><span class="p">(</span><span class="k">const</span> <span class="kt">void</span><span class="o">*</span> <span class="n">addr</span><span class="p">);</span>
<span class="c1">// 成功返回0，出错返回-1</span>
</pre></div>
</div>
<p>如果成功，shmdt将使相关shmid_ds结构中的shm_nattch计数器值减1。</p>
</div>
<div class="section" id="posix">
<h2>POSIX信号量<a class="headerlink" href="#posix" title="永久链接至标题">¶</a></h2>
<p>POSIX信号量有两种形式：命名的和未命名的。它们的差异在于创建和销毁的形式上，但其他工作一样。</p>
<ul class="simple">
<li><p>未命名信号量只存在于内存中，并要求能使用信号量的进程必须可以访问内存。这意味着它们只能应用在同一进程中的线程，或者不同进程中已经映射相同内存内容到它们的地址空间中的线程。</p></li>
<li><p>命名信号量可以通过名字访问，可以被任何已知它们名字的进程中的线程使用。</p></li>
</ul>
<p>我们可以调用sem_open函数来创建一个新的命名信号量或者使用一个现有信号量。</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;semaphore.h&gt;</span><span class="cp"></span>

<span class="n">sem_t</span><span class="o">*</span> <span class="nf">sem_open</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">name</span><span class="p">,</span> <span class="kt">int</span> <span class="n">oflag</span><span class="p">,</span> <span class="p">...</span> <span class="cm">/* mode_t mode, unsigned int value */</span> <span class="p">);</span>
<span class="c1">// 成功返回指向信号量的指针，出错返回SEM_FAILED</span>
</pre></div>
</div>
<p>当使用一个现有的命名信号量时，仅需指定信号量的名字，并将oflag设置为0。</p>
<p>当oflag参数有O_CREAT标志集时，如果命名信号量不存在，则创建一个新的。如果它已经存在，则会被使用，但是不会有额外的初始化发生。</p>
<p>当我们指定O_CREAT标志时，需要提供两个额外的参数。mode参数指定谁可以访问信号量。mode的取值和打开文件的权限位相同：用户读、用户写、用户执行、组读、组写、组执行、其他读、其他写和其他执行。赋值给信号量的权限可以被调用者的文件创建屏蔽字修改。</p>
<p>在创建信号量时，value参数用来指定信号量的初始值。它的取值是0～SEM_VALUE_MAX。</p>
<p>如果我们想确保创建的是信号量，可以设置oflag参数为O_CREAT |
O_EXCL。如果信号量已经存在，会导致sem_open失败。</p>
<p>信号量命名规范：</p>
<ul class="simple">
<li><p>名字的第一个字符应该为斜杠（/）。</p></li>
<li><p>名字不应包含其他斜杠以此避免实现定义的行为。</p></li>
<li><p>信号量名字的最大长度是实现定义的。名字不应该长于_POSIX_NAME_MAX。</p></li>
</ul>
<p>可以调用sem_close函数来释放信号量相关的资源：</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;semaphore.h&gt;</span><span class="cp"></span>

<span class="kt">int</span> <span class="nf">sem_close</span><span class="p">(</span><span class="n">sem_t</span><span class="o">*</span> <span class="n">sem</span><span class="p">);</span>
<span class="c1">// 成功返回0，出错返回-1</span>
</pre></div>
</div>
<p>如果进程没有首先调用sem_close而退出，那么内核将自动关闭任何打开的信号量。</p>
<p>可以使用sem_unlink函数来销毁一个命名信号量。</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;semaphore.h&gt;</span><span class="cp"></span>

<span class="kt">int</span> <span class="nf">sem_unlink</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">);</span>
<span class="c1">// 返回值：若成功，返回0；若出错，返回-1</span>
</pre></div>
</div>
<p>sem_unlink函数删除信号量的名字。如果没有打开的信号量引用，则该信号量会被销毁。否则，销毁将延迟到最后一个打开的引用关闭。</p>
<p>可以使用sem_wait或者sem_trywait函数来实现信号量的减1操作(即P操作)。</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;semaphore.h&gt;</span><span class="cp"></span>

<span class="kt">int</span> <span class="nf">sem_trywait</span><span class="p">(</span><span class="n">sem_t</span><span class="o">*</span> <span class="n">sem</span><span class="p">);</span>
<span class="kt">int</span> <span class="nf">sem_wait</span><span class="p">(</span><span class="n">sem_t</span><span class="o">*</span> <span class="n">sem</span><span class="p">);</span>
<span class="c1">// 成功返回0，出错返回−1</span>
</pre></div>
</div>
<p>使用sem_wait函数时，如果信号量计数是0就会阻塞。直到成功使信号量减1或者被信号中断时才返回。</p>
<p>调用sem_trywait时，如果信号量是0，则不会阻塞，而是会返回−1并且将errno置为EAGAIN。</p>
<p>还可以使用sem_timedwait函数来指定最大等待时间：</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;semaphore.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;time.h&gt;</span><span class="cp"></span>

<span class="kt">int</span> <span class="nf">sem_timedwait</span><span class="p">(</span><span class="n">sem_t</span><span class="o">*</span> <span class="kr">restrict</span> <span class="n">sem</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="nc">timespec</span><span class="o">*</span> <span class="kr">restrict</span> <span class="n">tsptr</span><span class="p">);</span>
<span class="c1">// 返回值：若成功，返回0；若出错，返回−1</span>
</pre></div>
</div>
<p>如果超时到期并且信号量计数没能减1，sem_timedwait将返回-1且将errno设置为ETIMEDOUT。</p>
<p>可以调用sem_post函数使信号量值增1(即V操作)：</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;semaphore.h&gt;</span><span class="cp"></span>

<span class="kt">int</span> <span class="nf">sem_post</span><span class="p">(</span><span class="n">sem_t</span><span class="o">*</span> <span class="n">sem</span><span class="p">);</span>
<span class="c1">// 成功返回0，出错返回−1</span>
</pre></div>
</div>
<p>调用sem_post时，如果在调用sem_wait（或者sem_timedwait）中发生进程阻塞，那么进程会被唤醒并且被sem_post增1的信号量计数会再次被sem_wait（或者sem_timedwait）减1。</p>
<p>可以调用sem_init函数来创建一个未命名的信号量。</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;semaphore.h&gt;</span><span class="cp"></span>

<span class="kt">int</span> <span class="nf">sem_init</span><span class="p">(</span><span class="n">sem_t</span><span class="o">*</span> <span class="n">sem</span><span class="p">,</span> <span class="kt">int</span> <span class="n">pshared</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">value</span><span class="p">);</span>
<span class="c1">// 成功返回0，出错返回−1</span>
</pre></div>
</div>
<p>pshared参数表明是否在多个进程中使用信号量。如果是，需要设置成一个非0值。</p>
<p>value参数指定了信号量的初始值。</p>
<p>可以调用sem_destroy函数销毁未命名的信号量：</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;semaphore.h&gt;</span><span class="cp"></span>

<span class="kt">int</span> <span class="nf">sem_destroy</span><span class="p">(</span><span class="n">sem_t</span><span class="o">*</span> <span class="n">sem</span><span class="p">);</span>
<span class="c1">// 成功返回0，出错返回−1</span>
</pre></div>
</div>
<p>可以使用sem_getvalue函数来检索信号量值：</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;semaphore.h&gt;</span><span class="cp"></span>

<span class="kt">int</span> <span class="nf">sem_getvalue</span><span class="p">(</span><span class="n">sem_t</span> <span class="o">*</span><span class="kr">restrict</span> <span class="n">sem</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="kr">restrict</span> <span class="n">valp</span><span class="p">);</span>
<span class="c1">// 成功返回0，出错返回−1</span>
</pre></div>
</div>
<p>调用成功后，valp指向的整数值将包含信号量值。</p>
<blockquote>
<div><p>但是我们试图要使用我们刚读出来的值的时候，信号量的值可能已经变了。除非使用额外的同步机制来避免这种竞争，否则sem_getvalue函数只能用于调试。</p>
</div></blockquote>
<p>用信号量来实现自己的锁结构：</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">// slock.h</span>
<span class="cp">#include</span> <span class="cpf">&lt;semaphore.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;fcntl.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;limits.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;sys/stat.h&gt;</span><span class="cp"></span>

<span class="k">struct</span> <span class="nc">slock</span> <span class="p">{</span>
    <span class="n">sem_t</span><span class="o">*</span> <span class="n">semp</span><span class="p">;</span>
    <span class="kt">char</span> <span class="n">name</span><span class="p">[</span><span class="n">_POSIX_NAME_MAX</span><span class="p">];</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="nc">slock</span><span class="o">*</span> <span class="n">s_alloc</span><span class="p">();</span>
<span class="kt">void</span> <span class="nf">s_free</span><span class="p">(</span><span class="k">struct</span> <span class="nc">slock</span><span class="o">*</span><span class="p">);</span>
<span class="kt">int</span> <span class="nf">s_lock</span><span class="p">(</span><span class="k">struct</span> <span class="nc">slock</span><span class="o">*</span><span class="p">);</span>
<span class="kt">int</span> <span class="nf">s_trylock</span><span class="p">(</span><span class="k">struct</span> <span class="nc">slock</span><span class="o">*</span><span class="p">);</span>
<span class="kt">int</span> <span class="nf">s_unlock</span><span class="p">(</span><span class="k">struct</span> <span class="nc">slock</span><span class="o">*</span><span class="p">);</span>
</pre></div>
</div>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&quot;slock.h&quot;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;unistd.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;errno.h&gt;</span><span class="cp"></span>

<span class="k">struct</span> <span class="nc">slock</span><span class="o">*</span> <span class="n">s_alloc</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="nc">slock</span><span class="o">*</span> <span class="n">sp</span><span class="p">;</span>
    <span class="k">static</span> <span class="kt">int</span> <span class="n">cnt</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">((</span><span class="n">sp</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="nc">slock</span><span class="p">)))</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">do</span> <span class="p">{</span>
        <span class="n">snprintf</span><span class="p">(</span><span class="n">sp</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">sp</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">),</span> <span class="s">&quot;/%ld.%d&quot;</span><span class="p">,</span> <span class="p">(</span><span class="kt">long</span><span class="p">)</span><span class="n">getpid</span><span class="p">(),</span> <span class="n">cnt</span><span class="o">++</span><span class="p">);</span>
        <span class="n">sp</span><span class="o">-&gt;</span><span class="n">semp</span> <span class="o">=</span> <span class="n">sem_open</span><span class="p">(</span><span class="n">sp</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">O_CREAT</span> <span class="o">|</span> <span class="n">O_EXCL</span><span class="p">,</span> <span class="n">S_IRWXU</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">while</span> <span class="p">((</span><span class="n">sp</span><span class="o">-&gt;</span><span class="n">semp</span> <span class="o">==</span> <span class="n">SEM_FAILED</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">errno</span> <span class="o">==</span> <span class="n">EEXIST</span><span class="p">));</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">sp</span><span class="o">-&gt;</span><span class="n">semp</span> <span class="o">==</span> <span class="n">SEM_FAILED</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">free</span><span class="p">(</span><span class="n">sp</span><span class="p">);</span>
        <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">sem_unlink</span><span class="p">(</span><span class="n">sp</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">sp</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">s_free</span><span class="p">(</span><span class="k">struct</span> <span class="nc">slock</span><span class="o">*</span> <span class="n">sp</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">sem_close</span><span class="p">(</span><span class="n">sp</span><span class="o">-&gt;</span><span class="n">semp</span><span class="p">);</span>
    <span class="n">free</span><span class="p">(</span><span class="n">sp</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">s_lock</span><span class="p">(</span><span class="k">struct</span> <span class="nc">slock</span><span class="o">*</span> <span class="n">sp</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nf">sem_wait</span><span class="p">(</span><span class="n">sp</span><span class="o">-&gt;</span><span class="n">semp</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">s_trylock</span><span class="p">(</span><span class="k">struct</span> <span class="nc">slock</span><span class="o">*</span> <span class="n">sp</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nf">sem_trywait</span><span class="p">(</span><span class="n">sp</span><span class="o">-&gt;</span><span class="n">semp</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">s_unlock</span><span class="p">(</span><span class="k">struct</span> <span class="nc">slock</span><span class="o">*</span> <span class="n">sp</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nf">sem_post</span><span class="p">(</span><span class="n">sp</span><span class="o">-&gt;</span><span class="n">semp</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="APUE-16.html" class="btn btn-neutral float-right" title="网络IPC：套接字" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="APUE-14.html" class="btn btn-neutral float-left" title="高级I/O" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        
        &copy; 版权所有 2021, snowzhao

    </p>
  </div>
    
    
    
    Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>